/**
 * SQL Sanitizer - Critical security layer for text-to-SQL
 *
 * This module validates and sanitizes SQL queries generated by the LLM
 * to prevent SQL injection, data corruption, and unauthorized operations.
 */

/**
 * List of dangerous SQL keywords that should never appear in user queries
 */
const DANGEROUS_KEYWORDS = [
  'DROP', 'DELETE', 'INSERT', 'UPDATE', 'ALTER', 'CREATE',
  'TRUNCATE', 'REPLACE', 'EXEC', 'EXECUTE', 'PRAGMA',
  'ATTACH', 'DETACH', 'VACUUM', 'REINDEX'
];

/**
 * Validate and sanitize an SQL query
 * @param {string} sqlQuery - The SQL query to validate
 * @returns {Object} - { isValid: boolean, sanitizedQuery: string|null, error: string|null }
 */
export function validateAndSanitize(sqlQuery) {
  try {
    // 1. Basic validation
    if (!sqlQuery || typeof sqlQuery !== 'string') {
      return {
        isValid: false,
        sanitizedQuery: null,
        error: 'Invalid SQL query: must be a non-empty string'
      };
    }

    // Remove leading/trailing whitespace and normalize
    let sanitized = sqlQuery.trim();

    // 2. Whitelist approach: Only allow SELECT statements
    const normalized = sanitized.toUpperCase();
    if (!normalized.startsWith('SELECT')) {
      return {
        isValid: false,
        sanitizedQuery: null,
        error: 'Only SELECT queries are allowed'
      };
    }

    // 3. Check for dangerous keywords
    for (const keyword of DANGEROUS_KEYWORDS) {
      if (normalized.includes(keyword)) {
        return {
          isValid: false,
          sanitizedQuery: null,
          error: `Forbidden SQL keyword detected: ${keyword}`
        };
      }
    }

    // 4. Prevent multiple statements (SQL injection via semicolons)
    const statements = sanitized.split(';').filter(s => s.trim());
    if (statements.length > 1) {
      return {
        isValid: false,
        sanitizedQuery: null,
        error: 'Multiple SQL statements are not allowed'
      };
    }

    // 5. Remove trailing semicolon if present
    if (sanitized.endsWith(';')) {
      sanitized = sanitized.slice(0, -1).trim();
    }

    // 6. Ensure LIMIT clause exists for safety
    if (!normalized.includes('LIMIT')) {
      sanitized += ' LIMIT 100';
    }

    // 7. Additional safety checks
    // Check for comment injection attempts
    if (sanitized.includes('--') || sanitized.includes('/*')) {
      return {
        isValid: false,
        sanitizedQuery: null,
        error: 'SQL comments are not allowed'
      };
    }

    return {
      isValid: true,
      sanitizedQuery: sanitized,
      error: null
    };
  } catch (error) {
    return {
      isValid: false,
      sanitizedQuery: null,
      error: `Sanitization error: ${error.message}`
    };
  }
}

/**
 * Check if a query appears to be a SELECT query
 * @param {string} query - The query to check
 * @returns {boolean}
 */
export function isSelectQuery(query) {
  if (!query || typeof query !== 'string') return false;
  return query.trim().toUpperCase().startsWith('SELECT');
}

/**
 * Estimate query complexity for routing decisions
 * @param {string} query - The SQL query
 * @returns {number} - Complexity score
 */
export function estimateComplexity(query) {
  if (!query) return 0;

  const upper = query.toUpperCase();
  let score = 0;

  // Count JOINs (more complex)
  const joinCount = (upper.match(/JOIN/g) || []).length;
  score += joinCount * 2;

  // Count subqueries (very complex)
  const subqueryCount = (upper.match(/\(\s*SELECT/g) || []).length;
  score += subqueryCount * 3;

  // Count aggregations
  const aggFunctions = ['COUNT', 'SUM', 'AVG', 'MIN', 'MAX', 'GROUP BY', 'HAVING'];
  for (const func of aggFunctions) {
    if (upper.includes(func)) score++;
  }

  // Count DISTINCT (adds complexity)
  if (upper.includes('DISTINCT')) score++;

  // Count ORDER BY
  if (upper.includes('ORDER BY')) score += 0.5;

  return score;
}

/**
 * Extract table names from a SELECT query
 * Useful for logging and analysis
 * @param {string} query - The SQL query
 * @returns {Array<string>} - Array of table names
 */
export function extractTableNames(query) {
  if (!query) return [];

  const tables = [];
  const fromMatch = query.match(/FROM\s+(\w+)/i);
  if (fromMatch) {
    tables.push(fromMatch[1]);
  }

  // Find JOIN clauses
  const joinMatches = query.matchAll(/JOIN\s+(\w+)/gi);
  for (const match of joinMatches) {
    tables.push(match[1]);
  }

  return [...new Set(tables)]; // Remove duplicates
}

export default {
  validateAndSanitize,
  isSelectQuery,
  estimateComplexity,
  extractTableNames
};
